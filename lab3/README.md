
# Laboratory Work nr. 3

*A shared whiteboard*

### Description

This lab assignment features a kind of line-drawing
application that works over the network and supports multiple
clients without any centralized servers.
The actions that can be performed by users are:
  - draw lines visible to all the listening peers
      (the lines are shown in different colors for different users
  - vote for clearing the board (if more than a half of active users press the
      `SPACE` bar, the whiteboard is cleard)
  - exit (by pressing `ESC` a user can exit the app and send a message to the peers
      that sais he left the game, as a result, his line
      is removed from the boards of the peers)


### How it works

Under the hood, every client uses a *Broadcast* UDP socket to "shout out"
the events that are generated by user input and at the
same time listens for similar messages from other peers.
Depending on the recieved messages, every app draws the appropriate representation
of the current states of the whiteboard.

### The Protocol

In order to make the peers understand each other, it was necessary to
develop a protocol that everyone would follow.
The main idea that I kept in mind while developing the protocol was
to make it as simple as possible, moreover, I wouldn't concern myself
with deliverability of packets unless there was an obvious issue with this.

Here is a simtle definition of the protocol:

```
Message := <UUID><Event>
UUID := 16 bytes of data
Event := <DrawPath> | <VoteClear> | <Bye>
  DrawPath := DRAWPATH <PathID> <X> <Y>
    PathId := Int
    X := Float
    Y := Float
  VoteClear := VOTECLEAR
  Bye := BYE
```

Every message that is broadcasted should contain a UUID and the Event itself.
The UUID is used to identify different peers. I chose to identify users by UUIDs
over IPs because this gives the possibility to run multiple instances of an application
on the same machine.

There are 3 possible events that the app can send:
  - `DrawPath` message contains a path ID and the coordinates of a point
      that should be associated with the respective path. A peer should send
      a different path ID for every new line that he draws.
  - `VoteClear` informs the peers of a wish to clear the board. Every client
      keeps track of the number of active users and compares it to the number of
      votes. When the number of votes gets past the half the number of peers the
      board is cleared.
  - `Bye` - this message is used to notify the peers that a client left the app
      and as a result the rest of the clients stop to keep record of his paths and delete those already drawn.


### Conclusion

It was a fun assignment and I had the oppurtunity to play around with
GLOSS - a nice graphics library for Haskell, and more important I got
to know how UDP works and how to flood the network with my own messages.

